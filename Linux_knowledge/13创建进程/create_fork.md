# 进程

## 获取进程id
```c
#include <unistd.h>
#include <stdio.h>
pid_d getpid(void);  //获取当前进程的id
pid_t getppid(void);  //获取父进程的id
```
## 创建进程
```c
#include <unistd.h>
pid_t fork(void);
```
该函数运行一次，返回两次。父进程中返回子进程的id，子进程中返回0，如果创建失败，返回-1。fork()的程序要执行两次。

```c++
fork();
if (getpid()>0){ // 父进程
    ...
}else{  // 子进程
    ...
}
```

- 父进程和子进程的运行顺序不确定
- 父进程和子进程共享代码段，但是子进程的数据是独立的副本。二者数据不会相互干扰。
- 父进程和子进程共享文件描述符，但是二者对文件描述符的操作是独立的，不会相互干扰。
- 父进程和子进程共享文件描述符的文件偏移量，但是二者对文件描述符的操作是独立的，不会相互干扰。
- 父进程和子进程共享环境变量，但是二者对环境变量的操作是独立的，不会相互干扰。
- 父进程和子进程共享信号处理函数，但是二者对信号处理函数的操作是独立的，不会相互干扰。

## 使用方法

1. 父进程复制自己。这种用法在网络服务程序中很常见，父进程等待客户端的连接请求，当请求到达时，父进程调用fork()，让子进程处理些请求，而父进程则继续等待下一个连接请求。

2. 父进程使用execl函数执行另一个程序。

## vfork()

vfork()和fork()类似，区别是vfork()创建的子进程与父进程共享数据段，并且子进程先运行，父进程后运行。vfork()的子进程会调用exec()或exit()函数，否则子进程会一直阻塞，父进程无法继续执行。